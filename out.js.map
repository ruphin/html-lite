{"version":3,"file":"out.js","sources":["src/lib/markers.js","src/lib/template-parser.js","src/lib/template-walker.js","src/lib/dom.js","src/lib/template.js","src/lib/template-result.js","src/lib/template-instance.js","src/lib/directive.js","src/lib/parts.js","src/lite-html.js"],"sourcesContent":["/**\n * @license\n * MIT License\n *\n * Copyright (c) 2018 Goffert van Gool\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nexport const marker = Math.random()\n  .toString(36)\n  .slice(2)\n  .padStart(10, '0');\nexport const templateMarker = `T${marker}`;\nexport const nodeMarker = `<!--${marker}-->`;\nexport const templateMarkerNode = `<!--${templateMarker}-->`;\n","/**\n * @license\n * MIT License\n *\n * Copyright (c) 2018 Goffert van Gool\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n// import { AttributeCommitter, CommentCommitter, NodePart, StyleCommitter } from './parts.js';\n\nimport { nodeMarker, templateMarkerNode } from './markers.js';\n\nconst tagRegex = /<([^\\0-\\x1F\\x7F-\\x9F \"'>=/]+)/;\n\n// Matches the name of the last attribute that is defined in the current string\nconst lastAttributeNameRegex = /[ \\x09\\x0a\\x0c\\x0d]([^\\0-\\x1F\\x7F-\\x9F \"'>=/]+)[ \\x09\\x0a\\x0c\\x0d]*=[ \\x09\\x0a\\x0c\\x0d\"']*$/;\n\nconst nodeEscapeRegex = /([>'\"])/;\nconst closeCommentString = '-->';\n\n// The output HTML string\nlet html;\n\n// The output Part descriptions\nlet parts;\n\n// The current Part that is being processed (for multi-part attributes, comments, and scoped contexts)\nlet currentPart;\n\n// The current Attribute that is being parsed (for multi-part attributes)\nlet currentAttr;\n\n// The content of the current tag (Everything between < and > characters) that should be included in `html`\nlet tagString;\n\n// The current context to be parsed [parseText|parseComment|parseScoped|parseTag|parseAttribute]\nlet parse;\n\n// The next context after parsing a complete tag [parseText|parseScoped]\nlet nextContext;\n\n// The delimiter for closing the current attribute that is parsed ['|\"]\nlet attributeDelimiter;\n\n// The tagname of the current tag being parsed.\n// parseScoped needs this to determine what tag closes the scope (`</${tag}>`)\nlet tag;\n\n/**\n * Parses a string that is in a free text context (anything outside html tags).\n * It consumes tokens from the input string until it enters another\n * context (through any html opening tag).\n *\n * If the end of the string is reached, it inserts a marker for a Node part.\n *\n * If all text tokens have been consumed, it changes the parsing context\n * (comment, or regular tag). Also sets the next context based on the tag\n * that is encountered (scoped, or text).\n *\n * If a template tag is encountered, it inserts a template marker.\n *\n */\nconst parseText = htmlString => {\n  const match = htmlString.match(tagRegex);\n  if (match) {\n    html += htmlString.slice(0, match.index);\n    htmlString = htmlString.slice(match.index);\n    if (htmlString.slice(0, 4) === '<!--') {\n      parse = parseComment;\n    } else {\n      parse = parseTag;\n      tag = match[1];\n      if (tag === 'script' || tag === 'style') {\n        nextContext = parseScoped;\n      } else {\n        if (tag === 'template') {\n          html += templateMarkerNode;\n        }\n        nextContext = parseText;\n      }\n    }\n    return htmlString;\n  } else {\n    html += htmlString + nodeMarker;\n    parts.push({ type: 'node' });\n    parse = parseText;\n  }\n};\n\n/**\n * Parses a string that is in a comment context.\n * It consumes tokens from the input string until the comment closes.\n *\n * If the end of the string is reached, it creates a comment Part.\n *\n * If all comment tokens have been consumed, it changes the context to parsing text.\n */\nconst parseComment = htmlString => {\n  const index = htmlString.indexOf(closeCommentString);\n  if (index >= 0) {\n    const commentEnd = index + 3;\n    if (currentPart) {\n      html += nodeMarker;\n      currentPart.strings.push(htmlString.slice(0, index));\n      parts.push(currentPart);\n      currentPart = undefined;\n    } else {\n      html += htmlString.slice(0, commentEnd);\n    }\n    parse = parseText;\n    return htmlString.slice(commentEnd);\n  } else {\n    if (!currentPart) {\n      currentPart = { type: 'comment', strings: [] };\n      htmlString = htmlString.slice(4);\n    }\n    currentPart.strings.push(htmlString);\n  }\n};\n\n/**\n * Parses a string that is in a scoped context like inside <style> or <script> blocks.\n * It consumes tokens from the input string until the tag closes.\n *\n * If the end of the string is reached, it creates a scoped Part.\n *\n * If all tokens have been consumed, it changes the context to parsing text.\n */\nconst parseScoped = htmlString => {\n  // Note: This strictly only allows the literal `</tag>` to close scoped tags\n  const closeTag = `</${tag}>`;\n  const index = htmlString.indexOf(closeTag);\n  if (index >= 0) {\n    const endIndex = index + closeTag.length;\n    if (currentPart) {\n      html += closeTag + nodeMarker;\n      currentPart.strings.push(htmlString.slice(0, index));\n      parts.push(currentPart);\n      currentPart = undefined;\n    } else {\n      html += htmlString.slice(0, endIndex);\n    }\n    parse = parseText;\n    return htmlString.slice(endIndex); // Continue parsing the next context\n  } else {\n    if (!currentPart) {\n      currentPart = { type: 'scoped', strings: [] };\n    }\n    currentPart.strings.push(htmlString);\n  }\n};\n\nconst parseTag = htmlString => {\n  let match = htmlString.match(nodeEscapeRegex);\n  if (match) {\n    const tagEnd = match.index + 1;\n    const tagStringEnding = htmlString.slice(0, tagEnd);\n    if (match[1] === `>`) {\n      if (currentPart) {\n        html += nodeMarker;\n        parts.push(currentPart);\n        currentPart = undefined;\n      }\n      html += tagString + tagStringEnding;\n      tagString = '';\n      parse = nextContext;\n    } else {\n      attributeDelimiter = match[1];\n      tagString += tagStringEnding;\n      parse = parseAttribute;\n    }\n    return htmlString.slice(tagEnd);\n  } else {\n    // Bare attribute\n    match = htmlString.match(lastAttributeNameRegex);\n    if (currentPart) {\n      currentPart.attrs.push({ name: match[1] });\n    } else {\n      currentPart = { type: 'attribute', attrs: [{ name: match[1] }] };\n    }\n    tagString += htmlString.slice(0, match.index);\n  }\n};\n\nconst parseAttribute = htmlString => {\n  const index = htmlString.indexOf(attributeDelimiter);\n  if (index >= 0) {\n    if (currentAttr) {\n      currentAttr.strings.push(htmlString.slice(0, index));\n      currentAttr = undefined;\n    } else {\n      tagString += htmlString.slice(0, index + 1);\n    }\n    parse = parseTag;\n    return htmlString.slice(index + 1);\n  } else {\n    if (currentAttr) {\n      currentAttr.strings.push(htmlString);\n    } else {\n      const match = tagString.match(lastAttributeNameRegex);\n      tagString = tagString.slice(0, match.index);\n      if (!currentPart) {\n        currentPart = { type: 'attribute', attrs: [] };\n      }\n      currentAttr = { name: match[1], strings: [htmlString] };\n      currentPart.attrs.push(currentAttr);\n    }\n  }\n};\n\nexport const parseStrings = strings => {\n  parts = [];\n  html = '';\n  tagString = '';\n  parse = parseText;\n\n  let htmlString;\n  const lastStringIndex = strings.length - 1;\n  for (let i = 0; i < lastStringIndex; i++) {\n    htmlString = strings[i];\n    do {\n      htmlString = parse(htmlString);\n    } while (htmlString !== undefined); // Important; we must continue parsing when string === ''\n  }\n  // Only parse the last string until we hit text context\n  // This is to close any remaining context surrounding the last part\n  htmlString = strings[lastStringIndex];\n  while (parse !== parseText) {\n    htmlString = parse(htmlString);\n  }\n  html += htmlString;\n  return { html, parts };\n};\n","/**\n * @license\n * MIT License\n *\n * Copyright (c) 2018 Goffert van Gool\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { marker, templateMarker } from './markers.js';\nconst walker = document.createTreeWalker(document, 128 /* NodeFilter.SHOW_COMMENT */, null, false);\n\nexport const templateWalker = (node, parts) => handler => {\n  const stack = [];\n  let commentNode;\n  walker.currentNode = node;\n  commentNode = walker.nextNode();\n\n  parts.forEach(part => {\n    // This while(true) looks scary, but we are guaranteed to break or throw an Error eventually\n    while (true) {\n      if (commentNode === null) {\n        walker.currentNode = stack.pop();\n      } else if (commentNode.data === marker) {\n        const markerNode = commentNode;\n        commentNode = walker.nextNode();\n        handler(markerNode, part);\n        break;\n      } else if (commentNode.data === templateMarker) {\n        const template = commentNode.nextSibling;\n        walker.currentNode = template.content;\n        stack.push(template);\n      }\n      commentNode = walker.nextNode();\n    }\n  });\n};\n","/**\n * @license\n * MIT License\n *\n * Copyright (c) 2018 Goffert van Gool\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { marker } from './markers.js';\n/**\n * Move nodes from to a new parent, or remove them from the old parent if no new parent is given\n */\nexport const moveNodes = (oldParent, previous = null, after = null, newParent, before) => {\n  let nodeToMove = previous ? previous.nextSibling : oldParent.firstChild;\n  if (nodeToMove !== null) {\n    // If the new Parent is a Node, we move the nodes instead of removing them\n    let move;\n    if (newParent instanceof Node) {\n      move = () => newParent.insertBefore(nodeToMove, before);\n    } else {\n      move = () => oldParent.removeChild(nodeToMove);\n    }\n    let nextNode;\n    while (nodeToMove !== after) {\n      nextNode = nodeToMove.nextSibling;\n      move(nodeToMove);\n      nodeToMove = nextNode;\n    }\n  }\n};\n\nexport const createTextNode = () => {\n  return document.createTextNode('');\n};\n","/**\n * @license\n * MIT License\n *\n * Copyright (c) 2018 Goffert van Gool\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { parseStrings } from './template-parser.js';\nimport { templateWalker } from './template-walker.js';\nimport { createTextNode, moveNodes } from './dom.js';\nimport { marker } from './markers.js';\n\n/**\n * Template holds the DocumentFragment that is to be used as a prototype for instances of this template\n * When a template is to be rendered in a new location, a clone will be made from this\n *\n * @prop {[String]} strings\n *   The unique string array that this template represents\n * @prop {[DocumentFragment]} element\n *   The DocumentFragment that can be cloned to make instances of this template\n * @prop {[Object]} parts\n *   The descriptions of the parts in this Template. Each part has a path which defines a unique location in the\n *   template DOM tree, a type which defines the part type, and an optional attribute which defines the name of\n *   the attribute this part represents.\n */\nexport class Template {\n  // TODO: Cleaner way to pass isSVG\n  constructor(strings, isSVG) {\n    const { html, parts } = parseStrings(strings);\n    const templateElement = document.createElement('template');\n    const walker = templateWalker(templateElement.content, parts);\n\n    // If the Template is an SVG type, wrap the template with an <svg> tag during parsing\n    if (isSVG) {\n      templateElement.innerHTML = `<svg>${html}</svg>`;\n      const content = templateElement.content;\n      const svgElement = content.firstChild;\n      content.removeChild(svgElement);\n      moveNodes(svgElement, null, null, content);\n    } else {\n      templateElement.innerHTML = html;\n    }\n\n    /**\n     * Prepare the template\n     *  * Insert individual TextNodes with parsed content inside scoped contexts (`<style>` and `<script>`)\n     *  * Insert CommentNodes surrounding NodeParts if it is missing siblings\n     */\n    walker((markerNode, partDescription) => {\n      if (partDescription.type === 'scoped') {\n        const scopedNode = markerNode.previousSibling;\n        partDescription.strings.forEach(string => {\n          scopedNode.appendChild(document.createTextNode(string));\n        });\n      } else if (partDescription.type === 'node') {\n        const previousSibling = markerNode.previousSibling;\n        if (!previousSibling) {\n          markerNode.parentNode.insertBefore(createTextNode(), markerNode);\n        }\n        const nextSibling = markerNode.nextSibling;\n        if (!nextSibling || nextSibling.data === marker) {\n          markerNode.parentNode.insertBefore(createTextNode(), nextSibling);\n        }\n      }\n    });\n\n    this.walker = walker;\n    this.element = templateElement;\n    this.parts = parts;\n\n    /**\n     * DEBUG\n     */\n    // const printFragment = this.element.content.cloneNode(true);\n    // const printNode = document.createElement('div');\n    // printNode.appendChild(printFragment);\n    // console.log('PREPARED', printNode.innerHTML);\n    // console.log('PARTS', this.parts);\n    /**\n     * END DEBUG\n     */\n  }\n}\n","import { Template } from './template.js';\n/**\n * A map that contains all the template literals we have seen before\n * It maps from a String array to a Template object\n *\n * @typedef {Map.<[String], Template>}\n */\nconst templateMap = new Map();\n\n/**\n * TemplateResult holds the strings and values that result from a tagged template string literal.\n * TemplateResult can find and return a unique Template object that represents its tagged template string literal.\n */\nexport class TemplateResult {\n  constructor(strings, values) {\n    this.strings = strings;\n    this.values = values;\n  }\n\n  /**\n   * @returns {Template}\n   *   A singleton Template object for this template string\n   *   Each evaluation of html`..` yields a new TemplateResult object, but they will have the same\n   *   Template object when they are the result of the same html`..` literal.\n   */\n  get template() {\n    // TODO: Fix for Safari\n    let template = templateMap.get(this.strings);\n    if (!template) {\n      template = this.__createTemplate();\n      templateMap.set(this.strings, template);\n    }\n    return template;\n  }\n\n  __createTemplate() {\n    return new Template(this.strings);\n  }\n}\n\nexport class SVGTemplateResult extends TemplateResult {\n  __createTemplate() {\n    return new Template(this.strings, true);\n  }\n}\n","import { NodePart, AttributeCommitter, CommentCommitter } from './parts.js';\nimport { templateWalker } from './template-walker.js';\n\n/**\n * An instance of a template that can be rendered somewhere\n *\n * @prop {Template} template\n *   The unique Template object that this is an instance of\n * @prop {[DocumentFragment]} fragment\n *   The DocumentFragment that is a clone of the Template's prototype DocumentFragment\n * @prop {[AttributePart|CommentPart|NodePart]} parts\n *   The parts that render into this template instance\n */\nexport class TemplateInstance {\n  constructor(template) {\n    const parts = [];\n    const fragment = document.importNode(template.element.content, true);\n    const walker = templateWalker(fragment, template.parts);\n    this.parts = parts;\n    this.template = template;\n    this.fragment = fragment;\n    window.weirdFragment = fragment;\n\n    walker((markerNode, partDescription) => {\n      const partType = partDescription.type;\n      if (partType === 'node') {\n        const part = new NodePart();\n        const beforeNode = markerNode.previousSibling;\n        markerNode.parentNode.removeChild(markerNode);\n        part.insertAfterNode(beforeNode);\n        parts.push(part);\n      } else if (partType === 'scoped') {\n        let before = markerNode.previousSibling.firstChild;\n        let after = before.nextSibling;\n        while (after) {\n          const part = new NodePart();\n          part.insertAfterNode(before);\n          parts.push(part);\n          before = after;\n          after = after.nextSibling;\n        }\n        markerNode.parentNode.removeChild(markerNode);\n      } else if (partType === 'comment') {\n        const node = markerNode;\n        const strings = partDescription.strings;\n        const committer = new CommentCommitter({ node, strings });\n        parts.push(...committer.parts);\n      } else if (partType === 'attribute') {\n        const node = markerNode.nextSibling;\n        partDescription.attrs.forEach(attribute => {\n          const committer = new AttributeCommitter({ node, ...attribute });\n          parts.push(...committer.parts);\n        });\n        markerNode.parentNode.removeChild(markerNode);\n      }\n    });\n  }\n\n  /**\n   * Render values into the parts of this TemplateInstance\n   *\n   * @param {[any]} values\n   *   An array of values to render into the parts. There should be one value per part\n   */\n  render(values) {\n    this.parts.map((part, index) => part.setValue(values[index]));\n    this.parts.map(part => part.commit());\n  }\n}\n","/**\n * @license\n * MIT License\n *\n * Copyright (c) 2018 Goffert van Gool\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nconst directives = new WeakMap();\n\nexport const isDirective = value => directives.has(value)\n\nexport const directive = directive => {\n  directives.set(directive, null);\n  return directive;\n};\n","/**\n * @license\n * MIT License\n *\n * Copyright (c) 2018 Goffert van Gool\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { TemplateResult } from './template-result.js';\nimport { TemplateInstance } from './template-instance.js';\nimport { moveNodes, createTextNode } from './dom.js';\nimport { isDirective } from './directive.js';\n\nexport const isPrimitive = value => value === null || !(typeof value === 'object' || typeof value === 'function');\nexport const isIterable = nonPrimitive => Array.isArray(nonPrimitive) || !!onPrimitive[Symbol.iterator];\n\n// A flag that signals that no render should happen\nexport const noChange = {};\n\n// A node type for empty parts\nconst emptyNode = {};\n\n// A node type for NodeParts that contain an iterable\nconst iterableNode = {};\n\nexport class NodePart {\n  // // node OR before and after _must_ be defined\n  // // If node is defined, this NodePart represents the position of that node in the tree\n  // // If before and after are defined, this NodePart represents the content between those nodes\n  // constructor({ node, before, after }) {\n  //   this.node = node || emptyNode;\n  //   this.value = noChange;\n  //   this.beforeNode = before || node.previousSibling;\n  //   this.afterNode = after || node.nextSibling;\n  // }\n\n  appendIntoNode(container) {\n    this.beforeNode = container.appendChild(createTextNode());\n    this.afterNode = container.appendChild(createTextNode());\n  }\n\n  insertAfterNode(beforeNode) {\n    this.beforeNode = beforeNode;\n    this.afterNode = beforeNode.nextSibling;\n  }\n\n  get parentNode() {\n    return this.beforeNode.parentNode;\n  }\n\n  setValue(value) {\n    this._pendingValue = value;\n  }\n\n  commit() {\n    while (isDirective(this._pendingValue)) {\n      const directive = this._pendingValue;\n      this._pendingValue = noChange;\n      directive(this);\n    }\n    const value = this._pendingValue;\n    if (value === noChange) {\n      return;\n    }\n    if (isPrimitive(value)) {\n      if (value !== this.value) {\n        this._renderText(value);\n      }\n    } else if (value instanceof TemplateResult) {\n      this._renderTemplateResult(value);\n    } else if (isIterable(value)) {\n      this._renderIterable(value);\n    } else if (value instanceof Node) {\n      this._renderNode(value);\n    } else if (value === nothing) {\n      this.value = value;\n      this.clear();\n    } else {\n      // Fallback, will render the string representation\n      this._renderText(String(value));\n    }\n    this.value = value;\n  }\n\n  /**\n   * Render a serializable value in this part\n   *\n   * Strings, Numbers, and Booleans are serializable\n   * Serializable values are rendered as textContent of a TextNode\n   */\n  _renderText(serializable) {\n    // If the text is not equal to the previously rendered value\n    if (this.value !== serializable) {\n      // If the node is a TextNode, replace the content of that node\n      // Otherwise, create a new TextNode with the primitive value as content\n      if (this.node && this.node.nodeType === 3) {\n        this.node.textContent = serializable;\n      } else {\n        this._renderNode(document.createTextNode(serializable));\n      }\n    }\n  }\n\n  /**\n   * Render a TemplateResult in this part\n   *\n   * Checks if this template has already been rendered in this part before.\n   * If so, re-use that TemplateInstance\n   * If not, create a new TemplateInstance\n   */\n  _renderTemplateResult(templateResult) {\n    this.templateInstances = this.templateInstances || new Map();\n    let instance = this.templateInstances.get(templateResult.template);\n    if (!instance) {\n      instance = new TemplateInstance(templateResult.template, this.parentNode, this.beforeNode, this.afterNode);\n      this.templateInstances.set(templateResult.template, instance);\n    }\n    if (this.node !== instance.fragment) {\n      this.clear();\n      this.parentNode.insertBefore(instance.fragment, this.afterNode);\n      this.node = instance.fragment;\n    }\n    instance.render(templateResult.values);\n  }\n\n  /**\n   * Render an iterable in this part\n   *\n   * Creates a part for each item in the iterable\n   * Render each iterable value in a part\n   */\n  _renderIterable(iterable) {\n    if (this.node !== iterableNode) {\n      this.clear();\n      this.node = iterableNode;\n      if (!this.iterableParts) {\n        this.iterableParts = [];\n      } else {\n        this.iterableParts.length = 0;\n      }\n    }\n\n    let index = 0;\n    let before = this.afterNode ? this.afterNode.previousSibling : this.parentNode.lastChild;\n    let after;\n    const parent = this.parentNode;\n    for (const value of iterable) {\n      let part = this.iterableParts[index];\n      if (part === undefined) {\n        after = createTextNode();\n        parent.insertBefore(after, this.afterNode);\n        part = new NodePart();\n        part.insertAfterNode(before);\n        this.iterableParts.push(part);\n        before = after;\n      }\n      part.setValue(value);\n      part.commit();\n      index++;\n    }\n    if (index === 0) {\n      moveNodes(parent, this.beforeNode, this.afterNode);\n    } else if (index < this.iterableParts.length) {\n      const lastPart = this.iterableParts[index - 1];\n      moveNodes(parent, lastPart.afterNode, this.afterNode);\n    }\n    this.iterableParts.length = index;\n  }\n\n  /**\n   * Render a DOM node in this part\n   */\n  _renderNode(node) {\n    // If we are not already rendering this node\n    if (this.node !== node) {\n      this.clear();\n      this.parentNode.insertBefore(node, this.afterNode);\n      this.node = node;\n    }\n  }\n\n  /**\n   * Clear out the content of this NodePart\n   *\n   * If the current node is part of a DocumentFragment (this NodePart rendered a TemplateResult)\n   * The current content is moved back into that fragment to be used again if the same fragment is rendered\n   * Otherwise, the current content is removed from the DOM permanently\n   */\n  clear() {\n    moveNodes(this.parentNode, this.beforeNode, this.afterNode, this.node instanceof DocumentFragment && this.node);\n    this.node = emptyNode;\n  }\n}\n\nexport class CommentCommitter {\n  constructor({ node, strings }) {\n    const parts = [];\n    const partCount = strings.length - 1;\n    this.node = node;\n    this.strings = strings;\n    this.parts = parts;\n    this.dirty = false;\n    for (let i = 0; i < partCount; i++) {\n      parts[i] = new CommentPart(this);\n    }\n  }\n\n  commit() {\n    if (this.dirty) {\n      let result = '';\n      const { node, strings, parts } = this;\n      const partCount = parts.length;\n      for (let i = 0; i < partCount; i++) {\n        result += strings[i];\n        result += parts[i].value;\n      }\n      result += strings[partCount];\n      node.textContent = result;\n      this.dirty = false;\n    }\n  }\n}\n\n// The node in the CommentPart constructor must be a CommentNode\nexport class CommentPart {\n  constructor(committer) {\n    this.committer = committer;\n  }\n\n  setValue(value) {\n    if (value !== noChange && (!isPrimitive(value) || value !== this.value)) {\n      if (isDirective(value)) {\n        value(this);\n      } else {\n        this.value = value;\n        this.committer.dirty = true;\n      }\n    }\n  }\n\n  commit() {\n    this.committer.commit();\n  }\n}\n\nexport class AttributeCommitter {\n  constructor({ node, name, strings }) {\n    const parts = [];\n    this.node = node;\n    this.name = name;\n    this.strings = strings;\n    this.parts = parts;\n    if (strings) {\n      const partCount = strings.length - 1;\n      for (let i = 0; i < partCount; i++) {\n        parts[i] = new AttributePart(this);\n      }\n    } else {\n      parts[0] = new AttributePart(this);\n    }\n    switch (name[0]) {\n      case '.':\n        this._render = this._renderProperty;\n      case '?':\n        this._render = this._render || this._renderBoolean;\n      case '@':\n        this._render = this._render || this._renderEvent;\n        this.name = name.slice(1);\n        break;\n      default:\n        this._render = this._renderAttribute;\n        this.name = name;\n    }\n  }\n\n  commit() {\n    let result;\n    const { strings, parts } = this;\n    if (strings) {\n      const partCount = parts.length;\n      result = '';\n      for (let i = 0; i < partCount; i++) {\n        result += strings[i] + parts[i].value;\n      }\n      result += strings[partCount];\n    } else {\n      result = parts[0].value;\n    }\n    this._render(result);\n  }\n\n  _renderProperty(value) {\n    this.node[this.name] = value;\n  }\n\n  _renderBoolean(boolean) {\n    if (this.value !== !!boolean) {\n      boolean ? this.node.setAttribute(this.name, '') : this.node.removeAttribute(this.name);\n      this.value = !!boolean;\n    }\n  }\n\n  _renderEvent(listener) {\n    if (this.value !== listener) {\n      this.node.removeEventListener(this.name, this.value);\n      this.node.addEventListener(this.name, listener);\n      this.value = listener;\n    }\n  }\n\n  _renderAttribute(string) {\n    if (this.value !== string) {\n      this.node.setAttribute(this.name, string);\n      this.value = string;\n    }\n  }\n}\n\n// TODO: multi-part attribute parts\nexport class AttributePart {\n  constructor(committer) {\n    this.committer = committer;\n  }\n\n  setValue(value) {\n    if (value !== noChange && !(isPrimitive(value) && value === this.value)) {\n      if (isDirective(value)) {\n        value(this);\n      } else {\n        this.value = value;\n        this.committer.dirty = true;\n      }\n    }\n  }\n\n  commit() {\n    this.committer.commit();\n  }\n}\n","/**\n * @license\n * MIT License\n *\n * Copyright (c) 2018 Goffert van Gool\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { TemplateResult, SVGTemplateResult } from './lib/template-result.js';\nimport { NodePart } from './lib/parts.js';\n\n// A lookup map for NodeParts that represent the content of a render target\nconst nodeParts = new WeakMap();\n\n/**\n * Tagging function to tag JavaScript template string literals as HTML\n *\n * @return {TemplateResult}\n *   The strings and values of the template string wrapped in a TemplateResult object\n */\nexport const html = (strings, ...values) => {\n  return new TemplateResult(strings, values);\n};\n\nexport const svg = (strings, ...values) => {\n  return new SVGTemplateResult(strings, values);\n};\n\n/**\n * Render content into a target node\n *\n * @param {any} content\n *   Any content you wish to render. Usually a template string literal tagged with the `html` function\n * @param {Node} target\n *   An HTML Node that you wish to render the content into.\n *   The content will become the sole content of the target node.\n */\nexport const render = (content, target) => {\n  // Check if the target has a NodePart that represents its content\n  let part = nodeParts.get(target);\n  if (!part) {\n    // If it does not, create a new NodePart\n    part = new NodePart();\n    part.appendIntoNode(target);\n    nodeParts.set(target, part);\n  }\n  // Task the NodePart of this target to render the content\n  part.setValue(content);\n  part.commit();\n};\n"],"names":["marker","Math","random","toString","slice","padStart","templateMarker","nodeMarker","templateMarkerNode","tagRegex","lastAttributeNameRegex","nodeEscapeRegex","closeCommentString","html","parts","currentPart","currentAttr","tagString","parse","nextContext","attributeDelimiter","tag","parseText","htmlString","match","index","parseComment","parseTag","parseScoped","push","type","indexOf","commentEnd","strings","undefined","closeTag","endIndex","length","tagEnd","tagStringEnding","parseAttribute","attrs","name","parseStrings","lastStringIndex","i","walker","document","createTreeWalker","templateWalker","node","handler","stack","commentNode","currentNode","nextNode","forEach","part","pop","data","markerNode","template","nextSibling","content","moveNodes","oldParent","previous","after","newParent","before","nodeToMove","firstChild","move","Node","insertBefore","removeChild","createTextNode","Template","[object Object]","isSVG","templateElement","createElement","innerHTML","svgElement","partDescription","scopedNode","previousSibling","string","appendChild","parentNode","this","element","templateMap","Map","TemplateResult","values","get","__createTemplate","set","SVGTemplateResult","TemplateInstance","fragment","importNode","window","weirdFragment","partType","NodePart","beforeNode","insertAfterNode","committer","CommentCommitter","attribute","AttributeCommitter","map","setValue","commit","directives","WeakMap","isDirective","value","has","isPrimitive","isIterable","nonPrimitive","Array","isArray","onPrimitive","Symbol","iterator","noChange","emptyNode","iterableNode","container","afterNode","_pendingValue","directive","_renderText","_renderTemplateResult","_renderIterable","_renderNode","nothing","clear","String","serializable","nodeType","textContent","templateResult","templateInstances","instance","render","iterable","iterableParts","lastChild","parent","lastPart","DocumentFragment","partCount","dirty","CommentPart","result","AttributePart","_render","_renderProperty","_renderBoolean","_renderEvent","_renderAttribute","boolean","setAttribute","removeAttribute","listener","removeEventListener","addEventListener","nodeParts","svg","target","appendIntoNode"],"mappings":"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"}